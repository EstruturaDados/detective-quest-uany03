#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * @brief Estrutura que representa um cÃ´modo (Sala) na mansÃ£o.
 *
 * Cada Sala armazena seu nome e ponteiros para os cÃ´modos
 * Ã  esquerda e Ã  direita (filhos da Ã¡rvore binÃ¡ria).
 */
typedef struct Sala {
    char nome[50];
    struct Sala *esquerda;
    struct Sala *direita;
} Sala;

/**
 * @brief Cria, de forma dinÃ¢mica, uma nova sala com o nome especificado.
 *
 * @param nome O nome do cÃ´modo a ser criado.
 * @return Um ponteiro para a Sala recÃ©m-criada.
 */
Sala* criarSala(const char *nome) {
    // AlocaÃ§Ã£o dinÃ¢mica de memÃ³ria para a nova sala
    Sala *novaSala = (Sala *)malloc(sizeof(Sala));

    // Verifica se a alocaÃ§Ã£o foi bem-sucedida
    if (novaSala == NULL) {
        perror("Erro de alocaÃ§Ã£o de memÃ³ria.");
        exit(EXIT_FAILURE);
    }

    // Copia o nome para a estrutura
    strncpy(novaSala->nome, nome, sizeof(novaSala->nome) - 1);
    novaSala->nome[sizeof(novaSala->nome) - 1] = '\0'; // Garantir terminaÃ§Ã£o da string

    // Inicializa os ponteiros dos filhos como NULL
    novaSala->esquerda = NULL;
    novaSala->direita = NULL;

    return novaSala;
}

/**
 * @brief Permite a navegaÃ§Ã£o interativa do jogador pela Ã¡rvore (mansÃ£o).
 *
 * Inicia a exploraÃ§Ã£o a partir do Hall de entrada e continua atÃ©
 * o jogador alcanÃ§ar um nÃ³-folha (cÃ´modo sem saÃ­da).
 *
 * @param atual O ponteiro para a sala atual onde o jogador estÃ¡.
 */
void explorarSalas(Sala *atual) {
    // VariÃ¡vel para armazenar a escolha do jogador
    char escolha;

    printf("\n--- InÃ­cio da ExploraÃ§Ã£o da MansÃ£o ðŸ—ï¸ ---\n");

    // Loop de exploraÃ§Ã£o que continua atÃ© que o cÃ´modo atual seja um nÃ³-folha
    while (atual != NULL) {
        printf("\nVocÃª estÃ¡ em: **%s**\n", atual->nome);

        // Verifica se Ã© um cÃ´modo terminal (nÃ³-folha)
        if (atual->esquerda == NULL && atual->direita == NULL) {
            printf("\nðŸŽ‰ ParabÃ©ns! VocÃª encontrou um cÃ´modo sem saÃ­da (fim da exploraÃ§Ã£o)!\n");
            break; // Fim da exploraÃ§Ã£o
        }

        printf("Para onde vocÃª deseja ir? ");

        // OpÃ§Ãµes de navegaÃ§Ã£o:
        if (atual->esquerda != NULL) {
            printf("[(e) Esquerda -> %s] ", atual->esquerda->nome);
        }
        if (atual->direita != NULL) {
            printf("[(d) Direita -> %s] ", atual->direita->nome);
        }

        printf("ou [(s) Sair]: ");

        // Leitura da escolha do jogador
        if (scanf(" %c", &escolha) != 1) {
            // Tratar erro de leitura, se necessÃ¡rio
            break;
        }

        // ConversÃ£o para minÃºscula para flexibilidade
        escolha = tolower(escolha);

        // Processa a escolha do jogador
        if (escolha == 's') {
            printf("\n--- ExploraÃ§Ã£o encerrada pelo jogador. ---\n");
            break;
        } else if (escolha == 'e' && atual->esquerda != NULL) {
            atual = atual->esquerda; // Move para a esquerda
            printf("âž¡ï¸ Indo para a esquerda...\n");
        } else if (escolha == 'd' && atual->direita != NULL) {
            atual = atual->direita; // Move para a direita
            printf("âž¡ï¸ Indo para a direita...\n");
        } else {
            // OpÃ§Ã£o invÃ¡lida ou caminho indisponÃ­vel
            printf("\nðŸš« OpÃ§Ã£o invÃ¡lida ou caminho nÃ£o disponÃ­vel. Por favor, escolha 'e', 'd' ou 's'.\n");
            // NÃ£o avanÃ§a, o loop continua na sala atual
        }
    }
}

/**
 * @brief FunÃ§Ã£o principal: monta o mapa inicial da mansÃ£o e dÃ¡ inÃ­cio Ã  exploraÃ§Ã£o.
 *
 * Cria a Ã¡rvore binÃ¡ria de forma manual e inicia a navegaÃ§Ã£o a partir da raiz (Hall de entrada).
 */
int main() {
    // 1. Montagem do mapa da mansÃ£o (Ãrvore BinÃ¡ria)

    // NÃ­vel 0 (Raiz)
    Sala *hallDeEntrada = criarSala("Hall de Entrada");

    // NÃ­vel 1
    hallDeEntrada->esquerda = criarSala("Sala de Estar");
    hallDeEntrada->direita = criarSala("Biblioteca");

    // NÃ­vel 2
    hallDeEntrada->esquerda->esquerda = criarSala("Cozinha");
    hallDeEntrada->esquerda->direita = criarSala("Sala de Jantar");
    hallDeEntrada->direita->direita = criarSala("EscritÃ³rio"); // A Biblioteca nÃ£o tem caminho Ã  esquerda

    // NÃ­vel 3
    hallDeEntrada->esquerda->esquerda->direita = criarSala("Despensa"); // A Cozinha nÃ£o tem caminho Ã  esquerda
    hallDeEntrada->esquerda->direita->esquerda = criarSala("Jardim");
    hallDeEntrada->direita->direita->esquerda = criarSala("Quarto Principal");
    hallDeEntrada->direita->direita->direita = criarSala("Varanda");

    // Os nÃ³s: Despensa, Jardim, Quarto Principal, e Varanda sÃ£o folhas e terminam a exploraÃ§Ã£o.

    // 2. InÃ­cio da ExploraÃ§Ã£o
    explorarSalas(hallDeEntrada);

    // 3. Limpeza de MemÃ³ria (liberaÃ§Ã£o dos nÃ³s alocados dinamicamente)
    // Para simplificaÃ§Ã£o, faremos a limpeza apenas na main. Em um cÃ³digo mais complexo,
    // seria ideal uma funÃ§Ã£o recursiva de liberaÃ§Ã£o (ex: liberarSala(Sala*)).
    // A liberaÃ§Ã£o manual Ã© feita aqui para o exemplo simples:
    free(hallDeEntrada->esquerda->esquerda->direita); // Despensa
    free(hallDeEntrada->esquerda->direita->esquerda); // Jardim
    free(hallDeEntrada->direita->direita->esquerda); // Quarto Principal
    free(hallDeEntrada->direita->direita->direita); // Varanda

    free(hallDeEntrada->esquerda->esquerda); // Cozinha
    free(hallDeEntrada->esquerda->direita); // Sala de Jantar
    free(hallDeEntrada->direita->direita); // EscritÃ³rio

    free(hallDeEntrada->esquerda); // Sala de Estar
    free(hallDeEntrada->direita); // Biblioteca

    free(hallDeEntrada); // Hall de Entrada

    return 0;
}
